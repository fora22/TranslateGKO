PYTHON: PYTHONICNESS
As learning to understand how the Python can and be use on programming, there is a Python’s unique style of programming recommended for Python developer to implement as possible.

프로그래밍에 있어 파이썬이 무엇을 할 수 있고 어떻게 사용되는지에 대해 이해하는 것을 배우기 전에, 파이썬을 가능한 한 구현하려는 파이썬 개발자에게 추천되는 프로그래밍에 대한 독특한 스타일이 있다.

Zen of Python

파이썬의 좋은 점

A set of principle guide when coding Python, provided within Python itself. Accessible via example below.

파이썬을 코딩할때 원칙의 집합은 파이썬 내에서 제공된다. 아래 예시를 참고하라.

import this
Python Enhancement Proposals
Eight scripting style guides for Python suggested by experienced Python developers, aka. PEP8.

이를 받아들여라.

파이썬 향상 제안

파이썬을 위한 여덟 가지의 스크립팅 방식은 PEP8이라 불리는 경험많은 파이썬 개발자로부터 제안되었다.

Module should have short, all-lowercase name.
Class name should be in the CapWords style.
Most variables and function names should be lowercase_with_underscores.
Constants (variables that never change value) should be CAPS_WITH_UNDERSCORES.
Names that would clash with Python keywords (such as ‘class’ or ‘if’) should have a trailing underscore.
Line shouldn’t be longer than 80 characters.
from module import * should be avoided.
There should be only one statement per line.
Entry Point
While other program language such as C/C++ has a traditional entry point called main() which is the function where the program execution starts, Python does not have one.

모듈은 짧고, 소문자로 된 이름을 가져야만 한다.

클래스 명은 대문자로 지어져야 한다.

대부분의 변수와 함수는 언더바(_)와 소문자로 작성되어야 한다.

상수(값이 절대 변하지 않는 변수)는 언더바(_)와 함께 대문자로 작성되어야만 한다.

파이썬의 키워드(class, if와 같은)와 충돌 가능성이 있는 이름은 끝에 언더바(_)를 추가해주어야만 한다.

줄은 80개의 문자형보다 길 수 없다.

모듈의 불러오기는 피해야만 한다.

시작점

C/C++과 같은 언어는 프로그램이 시작되는 함수와 같은, main()이라 불리는 시작점이 있는 반면에 파이썬은 그러한 것이 없다.

Instead, Python uses special variable __name__ which indicates the current Python script being executed. When this script is the main executing file, the __name__ variable is assigned as "__main__" value.

대신에, 파이썬은 파이썬 스크립트가 실행되는 지점을 가리키는 특별한 변수명을 사용한다. 이 스크립트가 주 실행파일일 때, 변수명은 "main"처럼 할당된다.

# ENTRY POINT 시작점
if __name__ == "__main__":
    statements
Codes and statements indented under this condition will not be executed when it is imported as a module to the other script. Beware, the equivalent == operator cannot be replaced to logical is operator.

if __name__ == "__main__": 구문

위 조건 하에 작성된 코드와 구문들은 다른 스크립트에 모듈로 가져올 때 실행되지 않을 것이다.

주의할 것은, equivalent == operator는 logical is operator로 대체될 수 없다는 점이다.

PYTHON: REGULAR EXPRESSION
Regular expression is a domain specific language (DSL) for string manipulation. Regular expression is not Python-exclusive feature, and is utilized by other programming languages as well (aka. regex).

파이썬 : 정규식

정규식은 문자열 조작을 위한 영역 특화 언어이다. 정규식은 파이썬 전용기능은 아니지만, 다른 프로그래밍 언어들에 의해 활용되기도 한다.

re Module
The module which allows Python to access regular expressions. To use the regular expression, place the letter r before the string object which indicates raw string.

재구성

모듈은 정규식에 접근하기 위해 파이썬을 허용해주는 것이다. 정규식을 사용하기 위해, 비어 있는 문자열을 가리키는 문자열 객체 앞에 'r'을 붙여줘야 한다.

SYNTAX	EXAMPLE	DESCRIPTION
r	r"string"	Raw string object.
Special Sequences
In regular expression not only the backslash works as an escape character \ but also as a metacharacter that supports various features.

구문 예제에 대한 설명

특별한 순서

정규식에선 backslash가 확장문자 '\' 뿐만 아니라 다양한 기능들을 돕는 초문자로 구성되어 있다.



SYNTAX	EXAMPLE	DESCRIPTION
\	r"\"	Metacharacter for special sequence (+ escaper)
Grouping
Grouping makes series of characters or strings to be as one and allows grouped to become an argument for other metacharacters as seen in example of the previous section.

구문 예제에 대한 설명

\	r"" 특별한 순서를 위한 초문자(+escaper)

그룹화

그룹화는 일련의 문자나 문자열을 하나의 문자로 만들고, 그룹화가 이전의 섹션 예에서 보듯이 다른 초문자(metacharacter)의 인수가 되도록 허용한다.



OPERATION	EXAMPLE	DESCRIPTION
()	r"^str0(str1)"	Grouping str1 separately from str0 .
group()	re.search.group(...)	Method used for calling a grouped.
groups()	re.search.groups( )	Method used for calling all the groups in tuple.
Calling group(0) is same as group() which returns matched characters or strings between compared two. The rest of integer starting from 1 calls individual group starting from left to right and outer to inner group.



구동 예제 설명 

()	r"^str0(str1)"  str1을 str0과 구분이 되도록 묶는다.

group()	re.search.group(...) 그룹화된 것을 호출하기 위해 사용되는 방법

groups()	re.search.groups( ) 튜플에 있는 모든 그룹을 호출하기 위해 사용되는 방법

호출 그룹은 비교된 두 문자 간에 일치하는 문자 혹은 문자열을 반환하는 그룹과 같다. 1에서 시작하는 나머지 정수는 왼쪽에서 오른쪽, 바깥쪽에서 내부 그룹으로 시작하는 개별 그룹을 호출한다.



Named Groups
Group can be specified to have its own name to be called. No double quotations are needed when inserting name but are needed when calling the named groups.

지명된 그룹

그룹은 호출받을 자신의 이름을 가지도록 지정될 수 있다. 이름을 삽입 할 때는 두 번 인용의 필요는 없지만 지명된 그룹을 호출할 때에는 필요하다.



SYNTAX	EXAMPLE	DESCRIPTION
?P<>	r"(?P<name>string)"	Designate group with name for calling.
Non-capturing Groups
Group that cannot be accessible by group(...) and groups() methods, which results skipping index on such groups. However, group(0) is an exception where it calls matched comparison between two rather than groups.



구문 예제 설명

?P<>	r"(?P<name>string)"	호출하기 위해 지명한 그룹을 지정한다.

non-capturing 그룹

그룹(...)과 그룹() 방법으로 접근 할 수 없는 그룹의 경우, 해당 그룹에 대한  표시를 건너 뛰는 결과를 초래한다. 그러나, 그룹(0)은 그룹이 아닌 두 개의 일치 비교를 호출하는 경우는 예외로 한다.



SYNTAX	EXAMPLE	DESCRIPTION
?:	r"(?:string)"	Inaccessible via group(...) and groups() methods.
PYTHON: FILE MANAGEMENT
When using the Python in advanced scripting, such as use for scientific research and artificial intelligence, the input data that needs to be computed cannot be stored through console command of the Python and may need to read through files if necessary.



구문 예제 설명

?:	r"(?:string)"	그룹(...)과 그룹() 방법을 통해 접근이 되지 않을 경우

파이썬 :  파일 관리

과학적 조사나 인공지능에 대한 이용과 같은 진보된 scripting에 있어 파이썬을 사용 중일 때,  계산해야 하는 입력 데이터는 입력 데이터는 파이썬의 콘솔 명령으로 저장할 수 없으며 필요한 경우 파일을 읽어야 할 수 있을 지도 모른다.



Opening Files
Before reading or manipulating files via Python, the file must be opened firsthand. The open() function is used to open a file user want to open.



파일 열기

파이썬을 통해 파일을 일거나 조작하기 전에, 그 파일은 직접 열려 있어야만 한다. open() 함수는 사용자가 파일을 열고 싶어할 때 여는데 사용된다. 



open("filename.txt")
OPTION	DESCRIPTION
r	Read mode (default)
w	Write mode (rewrites content)
a	Append mode (adding new content)
rb	Binary read mode (non-text files)
wb	Binary write mode (non-text files)
The close() method is used to close currently opened files. Closing file in very important on avoiding wasting resource. Ensure the files are always closed even on exceptions by using try/except or with statement.



open("filename.txt")

옵션 설명

r	읽기 모드(기본)

w	작성 모드(고쳐쓰기)

a	추가 모드(새 코드 추가)

rb	이진 읽기 모드(text 파일 제외)

wb	이진 작성 모드(text 파일 제외)

close() 방법은 현재 열려 있는 파일들을 닫기 위해 사용되었다. 파일을 닫는 것은 리소 스 낭비를 방지하기 위해 가장 중요하다. 시도/제외 혹은 문구를 사용하여 예외의 경우에도 파일들이 항상 닫혔도록 확인해라.



variable = open("file.txt", "r")
variable.close()
with Statement
The with statement creates temporary variable only available inside an indented code block of the with statement. When the file is opened using this statement, the file automatically closes at the end of the code block even if exceptions occur within it.



variable = open("file.txt", "r")
variable.close()

with 구문

with 구문은 with 구문의 들여쓰기 된 코드 블록 안에서만 사용 가능한 임시 변수를 만들어낸다. 이 문구를 사용하여 파일을 열 때, 그것의 안에서 예외가 발생할지라도 파일은 코드 블록의 끝에 자동으로 닫힌다.



with open("file.txt") as variable:
    statements
Absolute & Relative Paths
Just as other programming languages are, Python have two different types of path: absolute and relative path. When designating a path, use double backslash \\ as a single backslash is an escape character that can cause unwanted operation.



변수로써의 with open("file.txt") : 구문

절대적인 경로 & 상대적인 경로

다른 프로그래밍 언어들이 그렇듯, 파이썬은 절대적인 경로와 상대적인 경로인 두 가지의 다른 타입의 경로를 가지고 있다. 단일 백슬래쉬가 원치 않는 작동을 유발할 수 있는 탈출 문자형인 것처럼 경로를 지정할 때 두 개의 백슬래쉬를 쓴다.



variable = open("path\\file.txt")
Reading Files
After opening the text-based file, Python can read lines of file’s content using read() method. Argument inside the method represent the number of bytes the method will read.

Read method can be used on the same file over again, but it will continue from where Python last read. When there’s no argument, the read method reads the rest of the text from where it last left off.



variable = open("path\\file.txt")

파일 읽기

텍스트 기반의 파일을 열고 난 후, 파이썬은 read() 방법을 사용하여 파일의 내용을 읽을 수 있다.

그 방법 내부의 인수는 그 방법이 읽을 바이트의 크기를 나타낸다.

Read 방법은 같은 파일에 계속해서 사용 될 수 있지만, 그것은 파이썬이 마지막으로 읽은 지점에서 계속될 것이다. 인수가 없다면, read 방법은 그것이 마지막으로 중단한 곳에서 텍스트의 나머지를 읽는다.



with open("path\\file.txt") as variable:
    print(variable.read(16))	# READ 16 BYTES FROM THE START OF THE CONTENT.
	print(variable.read(4))		# READ 4 BYTES FROM THE POINT AFTER PREVIOUS 16 BYTES.
	print(variable.read())		# READ THE REST OF THE TEXT AFTER PREVIOUS 4 BYTES.
	print(variable.read())		# READ NO TEXT AS NO MORE CONTENT TO READ.
The Readlines() method is used to return a list of text of each line. The method do accepts argument, but it works exactly same as a read method: it designates how many bytes to read.

("path\file.txt")를 열어 변수로 사용:

    print(variable.read(16))	# 내용의 시작점부터 16바이트를 읽음.
    print(variable.read(4))		# 이전의 16바이트를 읽은 시점에서 4바이트를 읽음.
    print(variable.read())		# 이전에 읽은 4바이트 지점부터 나머지를 읽음.
    print(variable.read())		# 더 이상 읽을 내용이 없으면 텍스트를 읽지 않음.
Readlines() 메서드는 텍스트의 각 줄을 반환하는데 사용된다. 메서드는 argument를 수용하지만, 얼마나 많이 읽어야하는지 지정해주는 read 메서드와 정확히 같은 동작을 한다.

Don’t get confused with Readlines() method which only reads the first line in string.

<file.txt>
First line here.
Second line there.
Last line somewhere.
with open("path\\file.txt") as variable:
    print(variable.readlines())
    print(variable.readline())
['First line here.\n','Second line there.\n','Last line somewhere.']
First line here.
Printing Line using Loop
Each line of text-base content can be retrieved using for loop statement:

오롯이 문자열의 첫번째 줄만 읽는 Readlines() 메서드와 혼동하면 안됨.

<file.txt>

첫번째 줄

두번째 줄

...

...

마지막 줄

with open("path\\file.txt") as variable:
    print(variable.readlines())
    print(variable.readline())
['첫번째 줄.\n','두번째 줄.\n','마지막 줄']
첫번째 줄
루프를 사용하는 출력문
텍스트 기반 내용의 각 줄은 루프문을 사용하기 위해 호출될 수 있음:



for variable in file:
    print(variable)
Writing Files
In Python, file can be created or (over)written by the write() method of the text-based file object. There are two options user can choose when writing: overwrite and append.

Suppose there is a file with text content written as follows:

for variable in file:
    print(variable)
Writing Files

파이썬에서,  파일은 텍스트 기반 파일 객체의 write() method에 의해 만들어지거나 작성(덮어쓰기)될 수 있음.  작성을 할 때, 사용자는 덮어쓰기와 덧붙이기의 두 가지 옵션 중 골라 사용할 수 있다.

<file.txt>
First line here.
Second line there.
Last line somewhere.
Overwrite mode w deletes all of previously existing content and write down fresh from the beginning.

<file.txt>
First line here.
Second line there.
Last line somewhere.

Overwrite mode(덮어쓰기)는 이전에 존재하는 모든 내용을 지워버리고 처음부터 새롭게 작성을 한다.



with open("path\\file.txt", "w") as variable:
    variable.write("TEXT OVERWRITTEN!")
<file.txt>
TEXT OVERWRITTEN!
On the other hand, append mode a does not delete existing content but continue writing from the end.

with open("path\\file.txt", "a") as variable:
    variable = variable.write("TEXT APPENDED.")
	print(variable)
<file.txt>
First line here.
Second line there.
Last line somewhere.TEXT APPENDED.
Upon successfully written, write() method returns the number of bytes written.



with open("path\\file.txt", "w") as variable:
    variable.write("TEXT OVERWRITTEN!")
<file.txt>
TEXT OVERWRITTEN!

반면에,  Append mode(덧붙이기)는 이전의 내용들을 지우지 않고 내용의 마지막에서부터 작성을 계속할 수 있다.

with open("path\\file.txt", "a") as variable:
    variable = variable.write("TEXT APPENDED.")
	print(variable)
<file.txt>
First line here.
Second line there.
Last line somewhere.TEXT APPENDED.

성공적으로 작성이 되면, write() 메서드는 작성된 바이트의 수를 반환한다.



Creating Files
New file can be created using the write() method which does not bound by just writing on existing file. Creating file is simply done by designating file name is doesn’t exist on the specified path.

파일 만들기

새로운 파일은 기존의 파일에 작성하는 것만으로 묶이지 않는 write() 메서드를 사용함으로써 만들어질 수 있다.

with open("path\\new-file.txt", "w") as variable:
    variable.write("NEW FILE CREATED!")
<new-file.txt>
NEW FILE CREATED!
PYTHON: PACKAGE
Python has variety of packages that can be easily downloaded and used on-demand. This chapter describes what the package is and how to implement it to the script.

파이썬은 쉽게 다운로드받고 주문형으로 사용될수 있는 다양한 패키지를 가지고 있다. 이번 챕터는 그 패키지가 무엇인지와 그 패키지를 어떻게 스크립트에서 구현하는지에 대해 설명한다.

Modules
A Python module is simply a Python source code file with .py extension. Developer may developed their own code containing class or function, and calling those codes from distribute Python file can be done using import keyword.

모듈

파이썬 모듈은 쉽게 말해 py. 확장자를 가진 파이썬의 소스코드이다. 개발자는 클래스나 함수를 포함하는 그들만의 코드를 개발할 수 있으며, 배포된 Python 파일에서 해당 코드를 호출하는 작업을  import 키워드를 통해 호출할 수 있다.

import module
module.function()
Above approach still requires name of the module to be mentioned every time when using its function. To ignore referring to the module while still using module’s function, use the from keyword beforehand.

import 모듈

module.function()

위의 접근법은 해당 기능을 사용할 때마다 모듈의 이름이 호출되는 것을 아직도 필요로 한다. 여전히 모듈의 기능을 사용하는 동안에 모듈의 호출을 무시하기 위해서는, 사전에 from 키워드를 사용해야 한다.

from module import function1, function2
from module import function as name
However, because module is not referred to use the function, there is potential conflict caused by function naming. Unless the function is named with guaranteed uniqueness, it is safe to use the previous approach to import modules.

from module import function1, function2
from module import function as name

그러나, 모듈이 해당 기능의 사용을 위해 호출이 되지 않았기 때문에, 기능의 호출로 인해 발생되는 잠재적인 충돌이 있다. 기능이 보장된 독특성으로 지명되지 않는 한, 모듈을 불러오기 위해 이전의 접근을 사용하는 것이 안전하다.

Package
Package is a directory of folder that holds a collection of Python modules or sub-packages. Every package folder must have a special Python file called __init__.py which can be blank or contains directory path of current package to prevent directories error caused by a common name.

Package

Package는 Python 모듈 혹은 하위 모듈의 집합을 포함하는 폴더의 디렉토리이다. 모든 패키지 폴더는 공란, 혹은 보편적인 이름으로 발생되는 디렉토리간의 에러를 방지하는 현재 패키지의 디렉토리 경로를 포함하는 init.py라고 불리는 특별한 파이썬 파일을 가지고 있어야만 한다.

import package.module
from package.module import function
Python Package Index
Python Package Index (aka. PyPI) is an external module storage website (https://pypi.python.org/pypi). To download and install the modules and packages, a software called pip is necessary.

import package.module
from package.module import function
Python Package Index

Python 패키지 인덱스(PyPI)는 외부 모듈이 저장된 사이트이다(https://pypi.python.org/pypi). 모듈과 패키지를 다운로드하고 설치하기 위해서는, pip이라 불리는 소프트웨어가 필요하다.

PIP
The pip software is a package management system required to install and manage the Python package. Nowadays, pip comes installed by default with modern distribution of Python. User can install pip separately online. Installation and management of packages are done using Command Prompt.

PIP

pip 소프트웨어는 파이썬 패키지를 설치하고 관리하기 위해 필요한 패키지 관리 시스템이다. 최근 들어, pip은 현재 Python의 유포와 함께 기본적으로 설치된다. 사용자는 온라인으로 pip만 설치할 수도 있다. 패키지의 설치와 관리는 명령 프롬프트를 사용한다.

NAME	DESCRIPTION	COMMAND
Installation	Install the package	pip install package
Remove	Uninstall the package	pip uninstall package
List	Show the list of packages	pip list
When using Python on Windows, it is recommended to use python -m pip instead of pip alone.

Name Description Command(이름 설명 명령어)

Installation	Install the package	pip install package
Remove	Uninstall the package	pip uninstall package
List	Show the list of packages	pip list

Windows에서 Python을 사용할 때, pip만 사용하는 것 대신에 python -m pip을 사용하는 것을 추천한다.

python -m pip
The command means accessing the pip under the python interpreter specified as python in environment variable. This allows package management by each interpreter more controllable, even when using virtual environment. When there is another version of Python installed, say 32 bits of Python 3.5

python -m pip

이 명령어는 환경변수에서 Python으로 지정된 Python 번역기 아래의 pip에 접근하는 것을 의미한다. 이것은 가상 환경을 이용할 때에도 각 번역기에 의한 패키지 관리가 더욱 쉽게 조작할 수 있게 한다. 다른 버전의 Python이 설치되어 있을 때, 32비트의 Python 3.5라고 부른다.

py -3.5-32 -m pip
PYTHON: VIRTUAL ENVIRONMENT
C-based project needs to include header files and libraries individually when compiling the script. Python, on the other hand, requires installation of modules under the interpreter directory.

py -3.5-32 -m pip
PYTHON: VIRTUAL ENVIRONMENT

C언어 기반의 프로젝트는 스크립트를 수행할 때, 헤더 파일들과 라이브러리들을 개별적으로 포함시키는 것을 필요로 한다. 반면, Python은 번역기 디렉토리의 하위에 모듈의 설치만을 필요로 한다.

However, when working with multiple Python projects, having all the packages installed in a single interpreter is inconvenient and inefficient. This is why separating Python environment is essential which can be done using virtual environment.

그러나, 여러 개의 Python 프로젝트를 작업할 때, 단일 통역기에 모든 패키지들을 설치하는 것은 편리하지도 않을 뿐더러 비효율적이다. 가상 환경을 사용하는 Python 환경을 분리하는 것이 필수적인 이유이다.

venv Package
The Python3 has virtual environment package venv included by default. The package support creating lightweight virtual environments with their own site directory, optionally isolated from system site directory.

venv Package

Python3에는 기본적으로 포함된 가상환경 패키지인 venv가 있다. 이 패키지는 선택적으로 시스템 사이트의 디렉토리에서 고립된 그들만의 사이트 디렉토리와 함께 가벼운 가상환경을 만드는 것에 도움을 준다.

Each virtual environment has its own Python binary (which matches the version of the binary that was used to create this environment) and can have its own independent set of installed Python packages in its site directory.

각 가상환경은 그들만의 고유한 Python 바이너리를 가지고 있으며, 사이트 디렉토리에 설치된 파이썬 패키지의 집합을 가질 수 있다.

Creating Environment
Creating a virtual environment under the name .venv on desired project directory is done as follows:

python -m venv D:\Workspace\Python\project\.venv
Activate Environment
Here, the term “activating” means activating virtual environment on the command prompt or terminal. While this is unnecessary when running the script under virtual environment, activation is required when installing packages using pip on console.

환경 만들기

원하는 프로젝트 디렉토리에 .venv라는 이름의 가상환경을 만드는 것은 다음과 같다.

python -m venv D:\Workspace\Python\project.venv

환경 활성화

여기서 "활성화"라는 용어는 명령 프롬프트 혹은 터미널에서 가상환경을 작동시키는 것을 의미한다.  이것이 가상 환경에서 스크립트를 실행할 때에는 불필요한 반면에, 콘솔에서 pip을 사용하여 패키지를 설치할 때에는 활성화가 요구된다.

Windows:

  D:\Workspace\Python\project\.venv\Scripts\activate.bat
Unix (e.g. Linux and macOS):

  source ~/Workspace/Python/project/.venv/bin/activate
Deactivate Environment
To exit from virtual environment activated console, user need to “deactivate” virtual environment.

윈도우:

D:\Workspace\Python\project.venv\scripts\activate.bat

Unix (e.g. Linux and macOS):

source-\Workspace\Python\project\.venv\bin\activate

비활동적인 환경

활성화된 콘솔의 가상환경에서 벗어나기 위해서, 사용자는 가상환경을 "비활성화" 할 필요가 있다.

deactivate
This is same as enter the command PATH=D:\Workspace\Python\.venv\Scripts\deactivate.bat. Because of this, relocating the virtual environment directory will cause deactivate command unable to recognize the path.

비활성화

이것은 명령어 PATH=D:\Workspace\Python.venv\Scripts\deactivate.bat에 들어가는 것과 같다. 이 때문에, 가상환경 디렉토리를 재배치하는 것은 경로 인식을 불가능하게 하는 비활성화 명령을 유발한다.

PYTHON: NUMPY
NumPy is an extremely powerful and useful library used in Python which supports multi-dimensional matrix (aka. NumPy array). As one of the best known scientific libraries, it is implemented on other well-recognized libraries such as Matplotlib, TensorFlow, et cetera.

Python: NUMPY

Numpy는 파이썬에서 사용되는, 다중 행렬을 보조하는 지극히 위력있고 유용한 라이브러리이다. 가장 잘 알려진 과학적 라이브러리들 중 하나로써, 그것은 Matplotlib, TensorFlow 및 cetera와 같이 다른 잘 알려진 라이브러리에서 실행된다.

To install NumPy library, open command prompt window and enter the command below:

python -m pip install numpy
Since NumPy is a huge scientific library and is still growing, this chapter will briefly introduce basic usage of the array. For more information on its API, refer to the following URL: https://numpy.org/

NumPy 라이브러리를 설치하기 위해, 윈도우의 명령 프롬프트를 열고 아래의 명령어를 실행한다.

python -m pip install numpy

NumPy가 거대한 과학적 라이브러리일 뿐 아니라 아직 성장하고 있기 때문에, 이 챕터는  배열의 기초적 사용법을 간단하게 소개하려 한다. API에 더 많은 정보를 원한다면, URL: https://numpy.org/ 에 접속해라.

NumPy Array
NumPy array is a very flexible matrix. Compared to Python’s List iterable object, the array has better performance both advantageous in faster speed and efficient memory management.

Declaration of the NumPy array is be done as follows:

import numpy as np

NumPy 배열

NumPy 배열은 굉장히 유연한 행렬이다. 파이썬 리스트의 수많은 객체에 비교해보면, 배열은 속도에서의 이점과 메모리 관리에서의 효율성 두 부분 모두에서 더 나은 수행능력을 가지고 있다.

# NUMPY DECLARATION : NumPy 선언

variable = np.ndarray(shape = (2, 3))
print(variable)
[[800191312     32765 800196048]
 [    32765 870097920     32765]]
This creates NumPy array object based on the given size, but its value is randomly generated.

Initialization of the NumPy array is done as follows:

import numpy as np

이것은 주어진 크기에 기반하여 NumPy 배열 객체를 만들지만, 그것의 값은 임의로 정해진다.

NumPy 배열의 초기화는 다음과 같이 이루어진다.

import numpy as np

# NUMPY INITIALIZATION : NumPy 초기화
variable = np.array([[1, 2, 3], [4, 5, 6]])
print(variable)
[[1 2 3]
 [4 5 6]]
This creates NumPy array object based on the given value, but has disadvantage on creating the array with huge size or deeper dimension.

이는 주어진 크기에 기반하여 NumPy 배열 객체를 만들지만, 크기가 큰 배열이나 고차원의 배열을 만드는 데에 있어서는 불이익을 가진다.

More NumPy methods exist that is used to create the array with better convenience:

NUMPY ARRAY	DESCRIPTION
np.zeros(shape)	Create a NumPy filled with number 0 with the size of shape.
np.ones(shape)	Create a NumPy filled with number 1 with the size of shape.
np.eye(N)	Create a NumPy identity matrix of N x N size.
np.full(shape, value)	Create a NumPy filled with value with the size of shape.

더욱 편리하게 배열을 생성하기 위해 사용되는 더 많은 NumPy 메서드가 존재한다.

NumPy 배열 설명

np.zeros(shape) : 배열의 크기에 기반하여 0으로 채워져 있는 NumPy를 만든다.

np.ones(shape) : 배열의 크기에 기반하여 1로 채워져 있는 NumPy를 만든다.

np.eye(N) : N * N 크기의 NumPy 단위행렬을 만든다.

np.full(shape, value) : 배열의 크기에 기반하여 넣은 값으로 채워져 있는 NumPy를 만든다.



NumPy Element
While accessing elements of NumPy array is similar to Python’s iterable object, but its syntax is different:

NumPy 요소

NumPy 배열의 요소에 접근하는 것은 Python의 반복 가능한 객체와 비슷하지만, 그것의 구문은 다르다.

import numpy as np
variable = np.array([[1, 2, 3], [4, 5, 6]])

print(variable[0])		# >> OUTPUT: [1, 2, 3]
print(variable[0, 1])	# >> OUTPUT: 2
NumPy Shape
Shape of the NumPy cannot be extracted using method of Python’s iterable object such as len(). Instead, NumPy has its own attribute containing length of each dimension.

NumPy shape

NumPy의 형태는 len()과 같은 Python의 반복가능 객체에서 사용하는 메서드로부터 추출될 수 없다.

import numpy as np
variable = np.array([[1, 2, 3], [4, 5, 6]])

variable.shape		# >> OUTPUT: (2, 3)
variable.shape[0]	# >> OUTPUT: 2
NumPy Indexing
The term “indexing” means slicing the array to specific range only. Each dimension is indexed using colon : and are distinguished via comma ,. Indexing shares the same rules as slicing of iterable object.

NumPy 색인

"색인"이라는 용어는 특정 범위만으로 배열을 나누는 것을 의미한다. 각각의 크기는 콜론(:)을 사용하여 색인이 되어있고, 쉼표(,)를 통해 구분된다. 색인하는 것은 수많은 객체의 부분처럼 같은 규칙을 공유한다.

n:m : start indexing from n^th^ element (included) to m^th^ element (excluded)
: : start indexing from beginning to the end, thus skip indexing.

: :색인을 처음부터 끝까지 시작하고, 따라서 색인을 건너뛴다.

import numpy as np
variable = np.array([[1, 2, 3], [4, 5, 6]])

print(variable[:, 1:-1])
[[1 2]
 [4 5]]
PYTHON: MATPLOTLIB
Matplotlib is a Python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. Developer can generate plots, histograms, power spectra, bar charts, error charts, scatterplots, and more with just a few lines of code.

Python : MATPLOTLIB

Matplotlib은 다양한 hardcopy 형식과 플랫폼 전반에 걸친 상호작용 환경에서 작품의 품질 수치를 산출하는 Python 2D 구성 라이브러리이다. 개발자는 단 몇 줄의 코드만으로 구성, 히스토그램, 동력 스펙트럼, 막대 차트, 에러 차트, 산점도 등을 만들어 낼 수 있다.

To install Matplotlib library, open command prompt window and enter the command below:

python -m pip install matplotlib
Since Matplotlib is a huge scientific library and is still growing, this chapter will briefly introduce basic terminology and its mechanism. For more information, refer to the following URL: https://matplotlib.org/

Matplotlib 라이브러리를 설치하기 위해서, 윈도우의 명령 프롬프트를 열고 아래의 명령어를 입력한다.

python -m pip install matplotlib

Matplotlib이 거대한 과학적 라이브러리이고 아직 성장중이기 때문에, 이 챕터에선 기초적인 용어와 그것의 매커니즘을 간단하게 설명할 것이다. 더 많은 정보를 원한다면, 다음의 URL로 들어갈 것.

URL : https://matplotlib.org/



Terminology
Matplotlib has various term user and developer may not be familiar of. This section is hereby provide terminology used in the library that could help understand. Below is a figure from official Matplotlib website:

용어

Matplotlib은 익숙치 않은, 다양한 용어 사용자와 개발자가 있다. 이 부분은 이쯤에서 이해에 도움을 줄 수도 있는 라이브러리에서 사용되는 용어를 제공한다.  아래는 공식 Matplotlib 사이트의 내용이다.

<img src=".\.images\Python\matplotlib_terminology.png" width=100%
Figure #. Matplotlib terminology.
Figure
Figure is considered an empty window of easel (a standing frame for a canvas):

<img src=".\.images\Python\matplotlib_figure_no_axes.png" width=70%>
Figure #. Matplotlib figure without any axes.
Calling a figure using API such as matplotlib.pyplot.figure() returns pure white window background without anything.

그림 #. 축이 없는 Matplotlib 그림

matplotlib.pyplot.figure()과 같은 API를 사용하는 그림을 누르면 아무것도 없는 순백의 윈도우 배경이 반환된다.

Axes
Axes (aka. subplot) is the region of the image with the data space, considered as canvas that goes up on easel. Do not be confused with axes and axis which is completely different. A following is a figure with four empty axes:

축

Axes(subplot)는 easel 위로 올라가는 캔버스로 고려되는 데이터 공간이 있는 이미지의 영역이다.

Axes와 완전히 다른 axis(축)과 혼동하지 말자. 다음은 네개의 빈 axes가 있는 형태이다.

<img src=".\.images\Python\matplotlib_figure_with_axes.png" width=70%>
Figure #. Matplotlib figure with four axes.
API such as matplotlib.pyplot.subplot() or matplotlib.pyplot.subplots() returns both figure and a single or multiple empty axes simultaneously.

그림 #. 네개의 axes가 있는 Matplotlib 형태

Matplotlib.pyplot.subplot() 혹은 matplotlib.pyplot.subplots()과 같은 API는 그림과 단일 혹은 다중의 빈 axes를 동시다발적으로 반환한다.

